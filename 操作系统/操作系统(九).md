# 操作系统(九)：虚拟内存

系统中进程之间是共享内存的，如果一个进程不小心写到别的进程使用的内存，就会产生令人迷惑的错误。

为了更好地管理内存并且少出错，现代系统提供了一种对 **内存的抽象** ，叫 **虚拟内存(VM)** 。

它为每个进程提供了一个很大，一致和私有的地址空间。

- 它把主存看成一个存储在磁盘的地址空间的高速缓存，在真实的主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，高效的使用了主存；
- 它为每个进程提供了一致的地址空间，每个进程不需要关心物理内存地址的编排，简化了内存管理；
- 保护每个进程的地址空间不被其他进程破坏。

本文前半篇描述虚拟内存是如何工作的，后半部分描述应用程序如何使用和管理虚拟内存。

## 物理和虚拟寻址

### 物理寻址

主存被组织一个由M个连续字节大小的单元组成的数组，每个字节都有一个唯一的物理地址，如第一个字节地址是0，第二个是1，第三个是2 。我们把这种最自然的方式称为物理寻址。

### 虚拟寻址

现代处理器使用的是虚拟寻址的寻址形式，CPU 通过生成一个虚拟地址来访问主存，这个虚拟地址在被送到内存之前先转换成适当的物理地址(地址翻译)，地址翻译需要内存管理单元MMU(CPU硬件) 和 利用放在主存中的查询表来动态翻译虚拟地址(操作系统管理)

## 地址空间

地址空间是一个非负整数地址的有序集合，主存中的每个字节都有一个选自虚拟地址空间的虚拟地址和一个选自物理空间的物理地址

## 虚拟内存作为缓存的工具

从概念上讲，虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的数组，每个字节都有一个唯一的虚拟地址。磁盘上数组的内容被缓存到主存中，磁盘上的数据被分割为块，这些块作为磁盘和主存之间的传输单元，系统通过将虚拟内存分割为虚拟页(大小固定的块)来处理。类似的物理内存也被分割为物理页。

虚拟内存有以下三个状态：

- **未分配的** 系统还未分配的页，没有任何数据和它们关联，不占用磁盘空间(未缓存)
- **缓存的** 当前已缓存在物理内存中的已分配的页(已分配，已缓存)
- **未缓存的** 未缓存在物理内存中的已分配的页(已分配，未缓存)

<img src="http://qiniu.itliusir.com/vp_pp.png" alt="vp &amp;&amp; pp" style="zoom:50%;" />

### DRAM缓存

SRAM 缓存表示位于CPU和主存之间的L1、L2、L3的高速缓存，DRAM 缓存表示虚拟内存系统的缓存，它在主存中 **缓存虚拟页** 

### 页表

页表可以理解一个表，里面每一条都包含了有效位和物理页号或者磁盘地址。

有效位用来表明该页是否被缓存在 DRAM 中。

- **已缓存** 如果设置了有效位，那后面的地址字段就表示 DRAM 中相应物理页的起始位置
- **未缓存** 如果没有设置有效位，并且后面地址字段还不为空则这个地址指向虚拟页在磁盘的起始位置
- **未分配** 如果既没有设置有效位地址字段还为空则表示这个虚拟页还未被分配

<img src="http://qiniu.itliusir.com/page_table.png" alt="page table" style="zoom:50%;" />

> 由上面的页表结构就可以很清晰的知道如何读取字节了。
>
> 例如CPU想要读取包含在虚拟内存的 VP2，地址翻译硬件将虚拟地址作为索引找到了该页的条目，发现有效位已设置，地址翻译硬件就知道是已缓存了，那么就用其地址字段的物理地址来构造这个字的物理地址。

### 缺页

DRAM 缓存不命中称为 缺页(page fault) , 例如上图中 CPU 引用了VP3 中的一个字，VP3 并未缓存在 DRAM 中，地址翻译硬件从内存中读取 PTE3，有效位发现是0，表示未被缓存触发一个 **缺页异常** ，**缺页异常** 调用内核中的缺页异常处理程序，该程序会选择一个牺牲页(如VP4)，内核会修改 VP4 的页表条目，对外表示 旧的VP4 不再缓存在主存中。接下来内核从磁盘复制 VP3 到内存中的 旧VP4 ，更新 PTE3(有效位置1，地址执行物理内存旧的VP4位置)

 ## 虚拟内存作为内存管理的工具

按需页面调度和独立的虚拟地址空间结合对系统中内存的使用与管理造成了深远的影响。

### 简化链接

每个进程都有一个独立的页表，也即是一个独立的虚拟地址空间。这样的好处是每个进程的内存使用相同的基本格式，而不用关系实际存放在物理内存何处。例如我们看到代码段总是从虚拟地址0x400000开始，数据段紧随其后，栈占据用户进程地址空间最高的部分向下生长。这样抽象出来的一致性简化了链接器的设计和实现。

### 简化加载

向内存加载文件更容易和简单，加载器为他们分配虚拟页，并标记无效，把页表条目指向文件，接下来虚拟内存会按需调入数据页。

### 简化共享

在一些情况，需要进程来共享代码，例如调用的内核代码、标准库的程序。操作系统通过将不同进程中适当的虚拟页映射到相同的物理页面，而不是每个进程中都包括单独的内核和标准库副本。

### 简化内存分配

malloc时候，操作系统只需要分配N个连续的虚拟内存页面，并将其映射到物理内存中任意位置的N个位置。操作系统无需分配连续的物理内存，其页可以随机分散在物理内存中。

> 此外，虚拟内存还可以作为内存保护的工具，我们知道在 CPU 生成地址时，地址翻译硬件都会读 PTE。所以我们可以在 PTE 上添加一些额外的许可位来控制对虚拟页面的内容访问，例如是否内核模式，是否可读，是否可写等。

## Linux 中的虚拟内存

Linux 为每个进程维护了一个单独的虚拟地址空间，首先我们先看 Linux 是如何组织虚拟内存的，Linux 内核为每个进程维护了一个单独的任务结构(task_struct)

<img src="http://qiniu.itliusir.com/linux_vm.png" alt="linux_vm_struct" style="zoom:50%;" />

任务结构中的mm_struct 描述了虚拟内存的当前状态，其 pgd 表示第一级页表(为了节省内存开销，使用多级页表来实现)的基址，mmap 指向一个链表。每个链表的节点都表示当前虚拟地址空间的一个区域。

- vm_start 区域的起始处
- vm_end 区域的结束处
- vm_prot 区域所有页的许可权限(exec、read、write、none)
- vm_flags 区域的页面是共享还是私有(map_private、map_shared)
- vm_next 指向下一个节点区域

### 缺页异常处理

在 MMU 试图翻译某个虚拟地址时，触发了一个缺页，这个异常会把控制转移到内核的缺页处理程序，随后会判断虚拟地址是否合法(把地址与vm_start、vm_end 做比较)，如果非法则终止，如果合法则会继续判断所进行的内存访问是否合法(有无读、写、执行权限)，如果非法则终止。都合法通过后，内核会选择一个牺牲页面把它置换为新的页面并更新页表。接下来缺页处理程序控制返回后，CPU重启引起缺页的指令，这次 MMU 可以正常翻译该地址，也就不会再产生缺页中断了。

<img src="http://qiniu.itliusir.com/linux_page_fault.png" alt="page fault" style="zoom:50%;" />

### 内存映射

Linux 进程可以使用 mmap 函数来创建新的虚拟内存区域，并把对象映射到这些区域。

```c
#include <unistd.h>
#include <sys/mman.h>

void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);
```

- start 表示内核会尽可能从该位置开始的区域进行创建
- fd、length 将文件描述符 fd 指向的对象的一个连续的 chunk 映射到新的区域，连续的 chunk 大小为 length 字节
- offset 距离文件开始处，偏移量为 offset 字节的地方开始，也即是 length = fd_file_start - offset
- prot 对应 vm_area_struct 中的 vm_prot
- flags 对应 vm_area_struct 中的 vm_flags

<img src="http://qiniu.itliusir.com/linux_mmap.png" alt="mmap" style="zoom:50%;" />

例如我们让内核创建一个新的包含 size 字节的只读、私有、匿名页的虚拟内存区域

bufp = mmap(NULL, size, PROT_READ, MAP_PRIVATE, 0, 0);

> 删除虚拟内存函数是 munmap 函数

## 总结

虚拟内存是对主存的一个抽象，然后通过虚拟寻址的间接寻址方式来引用内存，并通过翻译硬件和页表项把虚拟地址翻译为物理地址。

现代操作系统通过把虚拟内存片和磁盘文件片关联起来来初始化虚拟内存片，这个过程称为内存映射。然而大多数程序以来动态内存分配(如JAVA)，它操作内存和释放内存以及收集不可达的块。