# 操作系统(三)：程序的机器级表示

对于我们程序员来说，编译器承担了生成汇编代码的大部分工作，我们为什么花时间去学习机器代码呢？我觉得最重要的一点是高级语言提供的高级抽象隐藏了我们想要了解的程序在运行时行为，这是我们兴趣驱动的一大阻碍，不搞清楚想必还是很虚。。。

## Intel 处理器模型的发展

- **8086**

  1978 年，29K 个晶体管。也是第一代单芯片、16位微处理器之一。

- **80286**

  1982 年，134K 个晶体管。构成了IBM PC-AT个人计算机的基础，也是MS windows 最初的使用平台。

- **i386**

  1985年， 275K 个晶体管。扩展到32位，增加了 flat addressing model 寻址(段基地址为0，线性地址=段内偏移=逻辑地址)。这也是Intel 系列中第一台全面支持 Unix 操作系统的机器。

- **i486**

  1989年，1.2M个晶体管。将浮点单元集成到了处理器芯片上。

- **Pentium(Pro MMX II III 4 4E)**

  1993～2004年，3.1M～125M个晶体管。期间增加了条件传送、处理整数等指令，引入了超线程(一个处理器上同时运行两个程序)。

- **Core 2**

  2006 年，291M个晶体管。Intel 的第一个多核微处理器，多个处理器集成在一个芯片上。

- **Core i7**

  2008起，781M+晶体管。既支持超线程，也有多核，增加了更多的指令和指令格式。

> **摩尔定律**
>
> ![](http://qiniu.itliusir.com/moore.png)
>
> 1965 年，Intel 公司的创始人Gordon Moore 根据当时的芯片技术，做出推断，未来十年芯片上的晶体管数量每年都会翻一番，这个推测就是摩尔定律。
>
> 反过来说，未来几年用一半的钱就能买到和现在性能一样的计算设备。想想是不是很激动呢？
>
> 但是摩尔定律实际上已经失效半个世纪了，Intel也被嘲讽为 “牙膏厂”。虽然CPU的性能几近止步，但依然没阻挡科学家的脚步，从单核到多核。科学家 Donald Ervin Knuth(计算机巨著TAOCP作者)评价这种情况：这种现象或多或少上是由于硬件设计者已经无计可施，把摩尔定律的责任推脱给了软件开发者(并发)。

## 程序编码

我们所写的程序往往是中高级抽象程度很高的语言，编译器会帮我们转化为可执行代码。

而对于机器级编程来说，其中两种抽象比较重要：

- **指令集体系结构或指令集架构(ISA)**

  **ISA** 定义机器级程序的格式和行为，定义了处理器的状态、指令的格式，每条指令对状态的影响。

- **虚拟内存**

  程序看到的内存模型是一个非常大的字节数组。

接下来我们看一些在C语言中不易观察而在机器代码直接可见的部分：

- **程序计数器**

  用 `%rip` 表示，指要执行下一条指令的内存地址

- **整数寄存器**

  存储地址或者整数数据，一般用来记录状态或临时数据

- **条件码寄存器**

  算术和逻辑指令的状态信息，例如实现 `if` 和 `while` 语句

- **向量寄存器**

  一个或多个整数或浮点数值

一条机器指令只会执行一个非常基本的操作。其编译过程我们在第二章已经讲过，这里就不再重复了。

## 数据格式

![](http://qiniu.itliusir.com/data_struc.png)

## 访问信息

![](http://qiniu.itliusir.com/eax.png)

可以看到不同位可以使用不同操作，高位的操作可以操作所表示范围内的全部操作。例如64位操作可以访问整个寄存器。

图中特别的是栈指针 `%rsp` 指明运行时栈的结束位置