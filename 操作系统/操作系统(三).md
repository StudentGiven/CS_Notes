# 操作系统(三)：程序的机器级表示

对于我们程序员来说，编译器承担了生成汇编代码的大部分工作，我们为什么花时间去学习机器代码呢？我觉得最重要的一点是高级语言提供的高级抽象隐藏了我们想要了解的程序在运行时行为，这是我们兴趣驱动的一大阻碍，不搞清楚想必还是很虚。。。

## Intel 处理器模型的发展

- **8086**

  1978 年，29K 个晶体管。也是第一代单芯片、16位微处理器之一。

- **80286**

  1982 年，134K 个晶体管。构成了IBM PC-AT个人计算机的基础，也是MS windows 最初的使用平台。

- **i386**

  1985年， 275K 个晶体管。扩展到32位，增加了 flat addressing model 寻址(段基地址为0，线性地址=段内偏移=逻辑地址)。这也是Intel 系列中第一台全面支持 Unix 操作系统的机器。

- **i486**

  1989年，1.2M个晶体管。将浮点单元集成到了处理器芯片上。

- **Pentium(Pro MMX II III 4 4E)**

  1993～2004年，3.1M～125M个晶体管。期间增加了条件传送、处理整数等指令，引入了超线程(一个处理器上同时运行两个程序)。

- **Core 2**

  2006 年，291M个晶体管。Intel 的第一个多核微处理器，多个处理器集成在一个芯片上。

- **Core i7**

  2008起，781M+晶体管。既支持超线程，也有多核，增加了更多的指令和指令格式。

> **摩尔定律**
>
> ![](http://qiniu.itliusir.com/moore.png)
>
> 1965 年，Intel 公司的创始人Gordon Moore 根据当时的芯片技术，做出推断，未来十年芯片上的晶体管数量每年都会翻一番，这个推测就是摩尔定律。
>
> 反过来说，未来几年用一半的钱就能买到和现在性能一样的计算设备。想想是不是很激动呢？
>
> 但是摩尔定律实际上已经失效半个世纪了，Intel也被嘲讽为 “牙膏厂”。虽然CPU的性能几近止步，但依然没阻挡科学家的脚步，从单核到多核。科学家 Donald Ervin Knuth(计算机巨著TAOCP作者)评价这种情况：这种现象或多或少上是由于硬件设计者已经无计可施，把摩尔定律的责任推脱给了软件开发者(并发)。

## 程序编码

我们所写的程序往往是中高级抽象程度很高的语言，编译器会帮我们转化为可执行代码。

而对于机器级编程来说，其中两种抽象比较重要：

- **指令集体系结构或指令集架构(ISA)**

  **ISA** 定义机器级程序的格式和行为，定义了处理器的状态、指令的格式，每条指令对状态的影响。

- **虚拟内存**

  程序看到的内存模型是一个非常大的字节数组。

接下来我们看一些在C语言中不易观察而在机器代码直接可见的部分：

- **程序计数器**

  用 `%rip` 表示，指要执行下一条指令的内存地址

- **整数寄存器**

  存储地址或者整数数据，一般用来记录状态或临时数据

- **条件码寄存器**

  算术和逻辑指令的状态信息，例如实现 `if` 和 `while` 语句

- **向量寄存器**

  一个或多个整数或浮点数值

一条机器指令只会执行一个非常基本的操作。其编译过程我们在第二章已经讲过，这里就不再重复了。

## 数据格式

![](http://qiniu.itliusir.com/data_struc.png)

## 访问信息

![](http://qiniu.itliusir.com/eax.png)

可以看到不同位可以使用不同操作，高位的操作可以操作所表示范围内的全部操作。例如64位操作可以访问整个寄存器。

图中特别的是栈指针 `%rsp` 指明运行时栈的结束位置

### 操作数

操作数用来指示出指令执行一个操作中要使用的源数据值，以及放置结果的目的位置

其分为三种类型：

- **立即数**

  表示常数值

- **寄存器**

  表示寄存器的内容

- **内存引用**

  根据地址访问某个内存的位置

![操作数的格式](http://qiniu.itliusir.com/operand.png)

### 数据传送

X86-64加了一条限制，传送指令的两个操作数不能都指向内存位置。如果是将一个内存地址复制到另一个内存地址需要两条指令：第一条将源值加载到寄存器中，第二条是将该寄存器值写入到目标位置

*exchange.c*

```c
#include <stdio.h>

int exchange(long *xp,long y) {
    long x = *xp;
    *xp = y;
    return x;
}
```

*汇编代码*

```shell
_exchange:
			 // 保存调用者栈基地址
       pushq	%rbp
       movq	%rsp, %rbp
       // 读取入参
       movq	%rdi, -8(%rbp)
       movq	%rsi, -16(%rbp)
       movq	-8(%rbp), %rsi
       movq	(%rsi), %rsi
       movq	%rsi, -24(%rbp)
       movq	-16(%rbp), %rsi
       movq	-8(%rbp), %rdi
       movq	%rsi, (%rdi)
       movq	-24(%rbp), %rsi
       // 返回
       movl	%esi, %eax
       popq	%rbp
       retq
```

c 代码很简单，第一行就是从内存中读出x，然后把y写入到xp指向的内存位置，最后返回x。

而汇编可以看到指令非常的多，基本都是mov指令

## 控制

前面我们所分析的都是直线代码一条接着一条顺序执行，而 C 语言我们知道有条件语句、循环语句和分支语句，而控制流则是实现条件行为的常见方法。

> 例如比较指令 cmpg、跳转指令 jmp，通过这些指令我们可以实现条件语句 分支语句 循环语句。

## 不同结构的分配

### 数组

设数据类型为 T, 整型常数为 N，则有数组 T A[N]，该声明首先会在内存中分配一个 L * N 字节的连续区域，其次用 A 来作为指向数组开头的指针，可以使用 0～N-1 索引来访问该数组元素。

### 结构(对象)

如 C 语言的 struct ，可以定义不同类型的字段或对象。

类似于数组的实现，本质上还是把所有组成部分都存放在内存中一段连续的区域内，而指向该结构的指针就是结构第一个字节的地址。编译器负责维护每个字段类型的信息和偏移量，以其偏移作为内存引用指令中的位移，从而使引用达到想要的结果。

> 需要注意的是数据对齐问题，即：通过提前定义地址大小来减少硬件的访问次数。



## 总结

在本文中，我们了解了通过编译器产生机器级程序的汇编代码实现部分，知道了函数调用的本质，知道了条件、循环、分支的实现，也知道了不同结构的底层是如何分配和访问的。