# MySQL 架构

## 1. MySQL 逻辑架构

下图展示了 MySQL 的逻辑架构图，主要分为三部分：连接管理器其实大多数基于网络的服务都有类似架构，连接器下面这部分则是 MySQL 的核心服务解析与优化，最后一层则是存储引擎。

<img src="http://qiniu.itliusir.com/mysql01.png" style="zoom:50%;" />

### 1.1 连接管理器

MySQL 支持下面三种客户端与服务端通信的方式。

- **TCP/IP**

  当客户端进程与服务端进程运行在不同主机时，通过 `TCP 网络协议` 进行通信。默认 `3306` 端口号，可以通过 `mysqld -P3307` 指定端口号启动服务端，然后通过 `mysql -hx.x.x.x -uroot -P3307 -p` 来连接服务端。

- **命名管道和共享内存**

  如果通信的服务器进程和客户端进程都在同一台 Windows 主机中，可以采用 `命名管道` 或 `共享内存` 来进行进程间通信。

- **Unix socket文件**

  如果通信的服务器进程和客户端进程都在同一台 类Unix 主机中，可以采用 `Unix域套接字文件` 来进行进程间通信

#### 1.1.1 新建连接

当一个客户端进程连接到服务器进程时，服务器进程都会创建一个线程来处理与这个客户端的交互。也即是每个客户端连接都会在服务器中拥有一个线程。5.5+版本的 MySQL 提供支持线程池的插件，可以使用池中少量线程来服务大量连接。

客户端连接到服务器是，服务器需要对其进行安全认证、权限校验。

#### 1.1.2 断开连接

当一个客户端进程断开与服务器连接时，服务器进程不会把与要断开的客户端交互进程销毁，而是缓存起来，下次分配给新的客户端时直接使用，节省线程新建的开销。

### 1.2 核心服务(解析、优化、执行)

#### 1.2.1 查询缓存

顾名思义，查询缓存是把刚刚处理过的查询请求文本和结果作为 `key value` 缓存起来，既然有缓存就会有缓存失效时候，只要表结构或者数据变化就会缓存失效。

在现代架构中，缓存往往在 web 服务之外单独架设，Mysql 为了维护缓存需要增加自身数据更新的复杂度，对于更新压力大的场景反而成为负担，MySQL 也提供了按需使用方式。在 8.0 版本则直接把该模块删掉了。

#### 1.2.2 解析

查询缓存没有命中则会进入查询阶段，服务端首先会对客户端传来的文本进行词法分析，词法识别后会做语法分析判断语法是否正确，然后把要查询的表、列、条件都提取出来放到服务端内部数据结构。

#### 1.2.3 优化

解析之后，服务端已经得到了需要的信息(表、列、条件)，但是我们写的 MySQL 语句执行起来效率可能并不是很高，会进行一些优化(使用哪个索引、多表的连接顺序)，优化的结果就是生成一个执行计划(使用哪些索引、多表连接顺序)。我们可以使用 `explain` 来查看语句的执行计划。

#### 1.2.4 执行器

执行器则是操作存储引擎，返回结果集

### 1.3 存储引擎

存储引擎负责 MySQL 中数据的存储和提取，服务端通过 API 与存储引擎通信。也即是面向接口编程，接口屏蔽了不同存储引擎的差异。

## 2. 并发控制

### 2.1 读写锁

读锁是共享的，写锁是排他的

### 2.2 锁粒度

MySQL 提供了多种选择，每种 MySQL 存储引擎可以自己实现锁策略和锁粒度，不同的锁粒度可以为某种场景提供更好地性能。

#### 2.2.1 表锁(table lock)

表锁会锁定整张表，一个用户在更新操作前会获得写锁，阻塞其他用户对该表的读写操作。

虽然存储引擎可以管理自己的锁，但是例如服务端会为 `ALTER TABLE` 之类使用表锁而忽略存储引擎的锁机制。

#### 2.2.2 行级锁(row lock)

行级锁只在存储引擎层实现，支持更好的并发处理，但是锁的开销也是最大的。

## 3. 事务

事务就是一组原子性的 SQL 查询，事务内的语句要么全部执行成功要么全部执行失败。

一个运行良好的事务处理系统需要具备如下 ACID 特性。

- **原子性**

  一个事务必须视为一个不可分割的最小工作单元，整个事务中所有操作要么全部成功要么全部失败回滚。

- **一致性**

  数据库总是从一个一致性到另一个一致性不会因为事务中断而产生莫名的结果

- **隔离性**

  一个事务在最终提交之前对其他事务通常是不可见的

- **持久性**

  一旦事务提交，所做修改就会永久保存在数据库中

一个实现了 ACID 的数据库通常会有更多的性能开销，这也是存储引擎分离的好处，可以根据业务是否需要事务处理来选择合适的存储引擎

### 3.1 隔离级别

在 `SQL 标准` 中定义了 4 种隔离级别，较低的级别支持更高的并发

#### 3.1.1 Read Uncommitted(未提交读)

事务的修改即使没有提交对其他事务也是可见的，实际应用很少使用

#### 3.1.2 Read Committed(提交读)

事务从开始直到提交之前所做的修改对其他事务是不可见的。两次执行同样查询可能会得到不同结果。

#### 3.1.3 Repeatable Read(可重复读)

同一事务多次读取同样记录结果是一致的，理论上无法解决幻读(A事务在读取某个范围内的记录时，B事务在该范围内插入了新的记录，A事务再次读取该范围记录会产生幻行)。InnoDB 和 XtraDB 存储引擎通过多版本并发控制(MVCC, Multiversion Concurrency Control) 解决了幻读的问题。该级别是 MySQL 默认隔离级别

#### 3.1.4 Serializable(可串行化)

最高隔离级别，强制事务串行执行避免了幻读问题。串行化会在读取的每一行数据上加锁，所以可能导致性能问题。

| 隔离级别 | 脏读可能性 | 不可重复读可能性 | 幻读可能性 | 加锁读 |
| -------- | ---------- | ---------------- | ---------- | ------ |
| RU       | Y          | Y                | Y          | N      |
| RC       | N          | Y                | Y          | N      |
| RR       | N          | N                | Y          | N      |
| S        | N          | N                | N          | Y      |

### 3.2 死锁

死锁是两个或多个事务在同一资源上相互占用并请求锁定对方占用资源而导致的循环竞争现象

### 3.3 事务日志

事务日志是为了提高事务的效率，存储引擎修改表数据时候只需要把行为记录持久在硬盘上的事务日志中，而不是每次把数据本身持久化到磁盘。事务日志是追加的方式，也即是顺序 I/O，事务日志持久后，内存中被修改的数据会慢慢刷回磁盘。称为预写式日志。

### 3.4 MySQL 中的事务

MySQL 默认采用自动提交 (AUTO COMMIT) 模式，也即是在不显示开始事务情况下，每个查询都会被当做一个事务执行提交操作。

```mysql
mysql> show variables like 'autocommit';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| autocommit    | ON    |
+---------------+-------+
1 row in set (0.01 sec)
```

## 4. 多版本并发控制(MVCC)

InnoDB 的 MVCC 是通过在每行记录后面保存两个隐藏的列来实现的，一个保存了行的创建时间，一个保存了行的过期时间(删除时间)。这个时间并不是真正的时间值而是系统版本号。

- **SELECT**

  InnoDB 只查找版本早于当前事务版本的数据行，这样可以确保事务读取的行是在事务开启之前就存在的或者是事务自身更新过的

  行的删除版本要么未定义，要么大于当前事务版本号，这样可以确保事务读取到的行在事务开始之前未被删除

- **INSERT**

  新插入的每一行保存当前系统版本号作为行版本号

- **DELETE**

  删除的每一行保存当前系统版本号作为行版本号

- **UPDATE**

  为插入一行新纪录保存系统版本号作为行版本号，同时保存当前系统版本号到原来行为作为行删除标识

> MVCC 只在 RR 和 RC 隔离级别下工作