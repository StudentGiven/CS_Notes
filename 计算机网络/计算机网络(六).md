# 计算机网络(六)：安全

安全通信需要具有下列所需要的特性：

1. 机密性(数据加密解密)
2. 报文完整性(防止恶意篡改)
3. 端点鉴别
4. 运行安全性

![窃听](http://qiniu.itliusir.com/%E7%AA%83%E5%90%AC.png)

## 密码学原则

### 对称加密

所有密码算法都涉及用一种东西替换另一种东西的思想，我们首先学习一下凯撒密码（Caesar cipher）找找感觉，这是一种加密数据的方法。

> 凯撒密码用于英语文本时，将明文报文中的每个字母用字母表中该字母后第k个字母进行替换（允许回绕，即把字母“a”排在字母“z”之后）。例如，如果k=3，则明文中的字母“a”变成密文中的字母“d”；明文中的字母“b”变成密文中的字母“e”，依此类推。

可见凯撒密码密钥只有英文字母间隔数，20来个，很快就能够破解。凯撒密码的一种改进方法是 `单码代替密码` ，也即是一个字母替换为该字母表的另一个字母。

![单码代替密码](http://qiniu.itliusir.com/%E5%8D%95%E7%A0%81%E6%9B%BF%E6%8D%A2.png)

其破解的数量级则由25升级为26! ，当然如果是对该内容较为熟悉，则可以根据固定可能出现的单词来减少试错次数。单码代替密码的改进方法是 `多码代替密码` ，即采用多套单码代替，比如明文中第一位使用第一套对应的加密，第二位使用第二套，第三位使用第三套，第四位采用第一套...and so on。

![多码代替密码](http://qiniu.itliusir.com/%E5%A4%9A%E7%A0%81%E6%9B%BF%E6%8D%A2.png)

回到现代社会中来，对称加密有两种宽泛的类型：`流密码` 和 `块密码` ，本节关注块密码。

块密码中，把要加密的报文处理为k比特的块，如 k = 3 ，则报文划分为3比特的块，每块独立加密

如 报文 `010 110 001 111` 加密成为 `101 000 111 001` 

![](http://qiniu.itliusir.com/%E5%9D%97%E5%AF%86%E7%A0%81.png)

由于维护映射表成本太大，全表块密码在所有输入输出之间提供了预先决定的映射，这不太可能。

取而代之的块密码通常使用函数模拟随机排列表，然后N次循环。AES使用128比特块，能够使用 128、192、256比特长的密钥进行操作，对于这种密码的每种进行蛮力攻击要循环通过所有密钥，可能需要的时间是万亿年。

![](http://qiniu.itliusir.com/%E5%9D%97%E5%AF%86%E7%A0%812.png)

### 公开密钥加密

![](http://qiniu.itliusir.com/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86.png)

尽管可能有许多算法处理这些关注的问题，但 `RSA` 算法（ `RSA algorithm` ，取算法创立人 `Ron Rivest、Adi Shamir` 和 `Leonard Adleman` 的首字母命名）几乎已经成了公开密钥密码的代名词

#### RSA 工作原理

设 n = pq，p和q是RSA算法中的大素数，RSA实验室推荐，公司使用时，p和q的乘积为1024比特的数量级。

1. 计算

 
$$
n = p*q 和 z = (p-1)*(q-1)
$$


2. 选择小于n的一个数字e，且e和z没有非1的公因数，例如p = 5，q = 7，n = 35 ，z = 24，e可以为5(5和24没有公因数)

3. 选择一个数d，使得e * d - 1 可以被z整除，例如第二条的数据，e = 5，z = 24 ，d可以为29。即：
   $$
   e*d mod z = 1
   $$

4. 公钥是(n,e)，私钥是(n,d)

加密过程：


$$
c = m^e mod n
$$
解密过程：
$$
m = c^d mod n
$$
所以可以看的出来，e和d取的值越大计算量越大

而私钥d的安全性可以看出来是依赖对一个大数的因数分解的难度，若数字很小，例如上文中的35，分解的素数为 5 和 7。那d很快就能推算出来。